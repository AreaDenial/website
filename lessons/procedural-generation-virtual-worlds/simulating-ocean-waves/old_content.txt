<p>Simulating ocean waves is probably with simulating color of the sky, one of the most fascinating things you can do in computer graphics (along side with things such as cloth, hair and more generally fluid simulation). It is of course an intricately hard problem because if simulating a small volume of water is hard, simulating a whole ocean should be if not impossible, near impossible. In fact the trick (but even the trick involves heavy computation as we shall see) is not so much to simulate the surface of the ocean as the result of simulating the whole body of water beneath the surface itself, but rather to directly compute the shape and the motion of the ocean’s surface as a result of direct observations and measurements oceanographers have made. Indeed, it turns out that the way waves appear and move on the surface of the ocean have a kind of regular pattern. Watching the waves moving up and down is rather relaxing because the motion is cyclic. Furthermore, waves are made up of a sum of waves whose size and height vary. You have big waves with a large amplitude on one side of the spectrum, and tiny waves with a small amplitude on the other, with a variety of waves in the middle going from one side of the spectrum to the other. If you read the chapter on the noise pattern from which fractal patterns can be made, the construction of the surface of the ocean is indeed somehow similar to that of the construction of a fractal made up of various levels of noise whose frequency and amplitude vary.</p>

<p>As we mentioned, oceanographers have measured the frequency properties of ocean surfaces for quite some time now an in the 1990s a researcher who played an important role in the CG community back then named Jerry Tessendorf developed a technique based on this data. His work was later used in the Titanic movie (1997) to simulate and render probably what happens to be the first photorealistic believable computer generated ocean surface ever displayed on a big screen. We can pay tribute to his work and contribution to the CGI community.</p>

<img class="left" style="width: 670px; margin-bottom: 12px;" src="/images/upload/ocean-simulation/Titanic.jpg">

<p>Before we present Jerry’s technique, we need to speak about a mathematical technique related to signal processing. It doesn’t matter if you are not familiar with that concept. The way we will speak about it in this lesson should be simple and self-contained enough for you to understand it, regardless of your background. The idea is simple. To make it short, any signal such as sound wave which can be seen as a function of time, can be decomposed into a series of frequencies. We say that the original signal is expressed in the <b>time or temporal domain</b> (in the case of a sound wave but we would speak of a spatial domain if we were to take the example of an image for example which we will get to in this lesson) and that the transformed signal is expressed in <b>frequency domain</b>. The inverse mathematical operation can be done: that is, we can go from frequency domain back to time or spatial domain and the resulting wave function will be the exactly the same as the original function. In other words, we can break a signal down into frequencies and rebuild or synthesize the original signal from these frequencies without any data loss.</p>

<p>The mathematical method that allows us to do this is called a <a href='https://en.wikipedia.org/wiki/Fourier_transform' target='_blank'><b>Fourier transform</b></a> (because it uses a technique invented by the mathematician <a href='https://en.wikipedia.org/wiki/Joseph_Fourier' target='_blank'>Joseph Fourier</a>). The reverse operation is called an inverse Fourier transform. The Fourier transform involves a few mathematical concepts which are quite advanced and hard to grasp at first. Namely we will speak and use the exponential function and complex numbers. These two notions are somehow interconnected. In this lesson we will just tell you how to map these mathematical concepts into code to keep the demonstration simple (and the lesson reasonably short). Please check the lesson devoted to frequency analysis in the mathematical section for more info.</p>

<p>Before we get into the math, let’s speak about Jerry’s method. As mentioned, we now know that we can decompose a signal into a series of frequencies and that if we know these frequencies, we can reconstruct the signal back. Regarding the motion and the appearance of ocean waves, the data regarding the waves’ frequency composition has been measured by oceanographers. Jerry’s thus suggested that if this frequency composition is known, it is thus possible to reconstruct an ocean surface from that data using, as you guessed it, an inverse Fourier transform. Simple and elegant.</p>

<p>In a glance, the method will thus consist of generating the frequency data (which can be done procedurally rather than from measurements because oceanographers also observed that the experimental data could be fit to mathematical functions) and from there use an inverse Fourier transform to generate a patch of ocean surface.</p>

<p>Before we get into a fast track course on Fourier transform, let’s just add that our method will have two constraints which we are not too problematic in our particular case. First, the number of frequencies we will be using and thus more generally the size of the patch of ocean water we will build (as the two numbers are related to each other), will need to be a power of 2 (64, 128, 256, 512, etc.). Second, in order for the kind of Fourier transform method we will be using in this lesson to work, the signal needs to be periodic. In other words, our patch of simulated ocean surface will be periodic in every direction. In a way this is convenient because by “gluing” a few patches together we can create a larger surface of water, but the problem with this method is that a pattern emerges as we look at these patches from the distance as shown below.</p>

<img class="left" style="width: 670px; margin-bottom: 24px;" src="/images/upload/ocean-simulation/wave-repeat.png">




/////////////////////////////////////////////////////////

<h1>A fast introduction to Fourier transform</h1>

<p>The idea of the Fourier Transform is that as mentioned before, a signal composed of real data can be decomposed into a series of frequencies. To begin with we will use a 1D function such as a sound wave but later we will show how to extend the method to 2D functions such as images. Before we get to that, let’s try to understand the idea of “decomposing a signal into frequencies” by intuition. Interestingly enough, it is easier to get an intuition of this concept by looking at images rather than using sound waves. In the image below we have three kind of rock patterns.</p>

<img class="left" style="width: 670px; margin-bottom: 12px;" src="/images/upload/ocean-simulation/ocean-pebble.png">

<p>In the left image we can see that the size of the pebble is extremely regular and that the pebbles are generally nicely spread across the image. If we were to translate this into frequencies we would say that generally the stones have the same frequency and that because we can only see pebbles in the image and nothing else, pebbles have maximum amplitude.
In the center image, we can see that this time, pebbles have different sizes. Translated to the frequency world, that means that very likely this image is composed of different frequencies one for each pebble size, for example large, middle and small.</p>

<p>Finally, on the right, we have pebbles or rocks too and they have the same size but this time there are few in the image. Their frequency should thus be rather uniform but they amplitude should be much lower than in the first example, since they don’t appear as often.</p>

<p>The Fourier transform will describe your image in terms of “what frequencies the elements making up the image have” and “what amplitude they have” which to some extent represents how often elements of a given frequency appear in the image. First image, a single frequency with a large amplitude is represented, second image, many frequencies with rather similar amplitudes are represented whereas in the last image, we have a unique frequency (when it comes to the rock) with a rather low amplitude. You can see a Fourier transform as a decomposition of the signal in terms of frequency and amplitude.</p>

<div class="captionImage right" style="width: 256px;">
<img class="left" style="width: 256px;" src="/images/upload/ocean-simulation/pebble-A.png?" />
<p class="caption left">Figure 1: the red line indicates the data that we will be using for our exercise.</p>
</div>

<p>Let’s now work on a concrete example. You need to know a few things about the Fourier transform. In this lesson, we will work with “discrete values” (or samples). In the particular case of a sound wave this will be the values (or samples) of the signal at each time step. In the case of an image row for example (which is a 1D signal), these are the brightness values of each individual pixels making up that row. Let’s verify our intuition with regards to our chosen set of image and do the following. Each image is 128 pixel wide. To start with, we will be using the image on the left and use the row in the middle of the image to get some discrete data (using the red channel). The image is stored in the PPM format which is a format you can read (we have explained how to do this on Scratchapixel many times). Let’s do it and display the resulting values.</p>

<img class="left" style="width: 670px; margin-bottom: 12px;" src="/images/upload/ocean-simulation/ocean-data.png">

<p>Now that we have some data, let’s apply the “Discrete” Fourier transform (since it will apply to discrete data, the 128 pixel values forming our signal) to transform it from “spatial” domain (each value in the signal corresponds to a given pixel position in the image’s row, thus it is indeed a function of space) into frequency domain.</p>

<p>This is where we start doing some maths. The Discrete Fourier Transform equation looks like this:</p>

$$ f(k) = \sum_{n=0}^{N-1} f(n) e^{-\dfrac{i 2\pi k n}{N}} $$

<p>The variable \( f(k) \) that we compute on the left is what we call the coefficient of the Fourier signal’s decomposition. In our particular case, the signal contains 128 values, therefore there will be 128 of these Fourier coefficients. Note that this not mandatory. We can “decompose” the input signal using less coefficients than the number of values contained in the input signal, but if you use less coefficients, you won’t be able to reconstruct a signal perfectly identical to the input signal later on. The equation says that for each one of these coefficients, we need to sum up all of the input function’s values multiplied by some term that includes an exponential function. The magic lies within that exponential function and more precisely the exponent of the Eleur's number \( e \). In there lies the letter ‘i’ which in fact means that we are not dealing with ordinary numbers so to speak but with what we call <b>imaginary numbers</b>. For now, don't try to make sense of what these strange numbers are. It is enough for you to know that these numbers are in fact composed of two parts, a real and an imaginary part. Mathematically it happens that an exponential function that contains a complex number in its exponent can be written in a different from:</p>

$$ e^{-ix} =\color{green}{ \cos(x) } -  \color{blue}{ i  \sin(x) } $$

<p>Where \( ix \) is a complex number. By the way <b>mind the minus sign in front of the exponent term</b>. This is known as the Euler’s formula, a <b>very</b> important formula in mathematics. Do not try to over think what this might mean. For now just consider this: it produces a complex number, a number that is made of a real part (in <b style="color: green">green</b>) and an imaginary part (in <b style="color: blue;">blue</b>) which are themselves trigonometric functions. For simplicity, we can “store” (from a programing point of view) the real part of the number (the \( \color{green}{ \cos(x) } \) term) into one variable, and the imaginary part (the \( \color{blue}{ i \sin(x) }\) term) into another variable. This would give.</p>

<div class="code" name="code">float real = ( cos(x));
float imag = (-sin(x));</div>

<p>What is the \( k \) term in the equation? As mentioned before, the number of coefficients in the Fourier decomposition of the input signal can be smaller than the length of the signal (denoted by \( N \)). This is what this term \( k \) relates to. It is the number of coefficients we wish to use for the signal’s decomposition or transform. In our particular case \( N=128 \) so we could use any value for \( k \) such as \( 0 \lt k \le N = 128\). However, as we already said if using less coefficients than the number of samples in the input data is possible, you need the same number of coefficients than the number of samples in the signal if you wish to be able to reconstruct the original signal from the coefficients later on by using the inverse discrete Fourier transform. Therefore, in our case we will use \( k = N \) coefficients.</p>

<p>C++ comes with a built-in complex type but for the sake of clarity, we will be using our own structure to store complex numbers. Here is a pseudo and naive implementation of the forward discrete Fourier transform (which converts a row of pixels from spatial to frequency domain):</p>

<div class="code" name="code">typedef struct
{
    float real;
    float imag;
} complex;

void DFT1D(const int N, const unsigned char *in, complex *out)
{
    for (int k = 0; k < N; ++k) {
        out[k].real = out[k].imag = 0; // init
        for (int n = 0; n < N; ++n) {
            out[k].real += (int)in[n] * ( cos(2 * M_PI * n * k / N));
            out[k].imag += (int)in[n] * (-sin(2 * M_PI * n * k / N));
        }
    }
}

complex *coeffs = new complex[N];
DFT1D(N, imageData, coeffs);</div>

<p>The result (output) is a row of complex numbers. The maths of imaginary numbers can be as confusing as considering a world in which more than 3 dimensions of space exists but the practical implementation as you can see is in fact rather simple. Hooray! Note that this function includes two inner loops of size \( N \). This is reason we say that this algorithm as \( O(N^2) \) complexity. To say it differently, the algorithm tends to slow down quickly as \( N \) increases. You may have heard of the Fast Fourier Transform or FFT which is an optimisation of that algorithm. In this particular lesson we will choose simplicity over speed, therefore we won't be using it.</p>

<p>Also you may get an insight of what the formula does. The term inside the \( \cos \) and \( sin \) function are sometimes called the angular term of the equation. What the Fourier transform does is to express the samples of the input function into a finite series of (complex) sinusoids with various (but fixed) frequencies (the \( 2 \pi  k  n / N \) term).</p>

<p>How de we now compute the inverse of the function? To understand this part, it is easier to start from a slightly more complex problem and work our way back. Imagine that we want to apply a Fourier transform and then its reverse onto the samples of an image. We are now dealing with a two-dimensional discrete Fourier transform (pixels are discrete values). Luckily solving this problem is simple because the Fourier transform is a kind of filter which is said to be “separable”. If a filter is separable, you can apply the filter to the row of the image, which reduces the problem to 1D case for which we already know the solution. This will give us as many “rows” of transformed lines of pixels as they are lines in the image. Then in a second step, we need to apply the 1D transform again on the resulting transformed lines but this time vertically. This idea is illustrating in the following image, where to keep things simple we used the example of an image that is 4x4 pixels wide.</p>

xx image xx

<p>The sequence of event with the resulting outcome is as follows:</p>

<p><b>STEP 1</b>: we start from real data, the pixels of the image which is a two-dimensional array. Let’s call this array A.</p>

<p><b>STEP 2</b>: we process the lines one by one (horizontally), and that gives us as many lines of “complex” numbers as they are rows in the image. We can pack all these lines in an array of complex numbers called B. In pseudo code that would give us:</p>

<div class="code" name="code">unsigned char A = new unsigned char[N * N * 3];
readPPM(A, “pebble-A.ppm”);
complex *B = new complex[N * N];

for (j = 0; j < N; ++j) {
    DFT1D(N, A + N * 3 * j, B + N * j);
}</div>

<p>With the <span class="code-inline">DFT1D</span> function looking like this:</p>

<div class="code" name="code">void DFT1D(const int N, const unsigned char *real, complex *coeffs) {
    …
}</div>

<p>As you can see our forward 1D Fourier transform takes real data as input and output complex numbers made of a real part and an imaginary part.</p>

<p><b>STEP 3</b>: then finally we process the data in B, but we will use the columns this time instead of the rows, to produce another two-dimensional array which we will call C. Let’s see what this looks like in pseudo code:</p>

<div class="code" name="code">// process all the columns of the B array (complex numbers)
complex *column = new complex[N];
complex *C = new complex[N * N]
for (i = 0; I < N; ++i) {
    // extract the data
    for (j = 0; j < N; ++j) {
        column[j] = B[j * N + i];
    }
    // process column with index i
    DFT1D(N, column, C + N * i);
}
// we don’t need these temo arrays any longer
delete [] column;
delete [] B;</div>

<p>Do you see a problem in this code from a programming standpoint? The problem is that the type of the second argument of the DFT1D function is an <span class="code-inline">unsigned char</span> whereas in the code above the variable that is being passed has type <span class="code-inline">complex</span>. It will obviously not work (not compile).</p>

<p>What’s wrong? In fact, in the world of mathematics the Discrete Fourier transform works with both real and complex numbers. At step 1 and 2, we only process real data, which is composed of the image pixel values. These are real world data and therefore have no imaginary part. Such numbers could very well be written like this:</p>

<div class="code" name="code">complex c;
c.real = pixel_value;
c.imag = 0;</div>

<p>In other words, we still start from complex numbers but since we fill them in with real world data, their imaginary part will just be left empty (set to 0). By doing so, we can develop a pipeline in which the forward Fourier transform will always process complex numbers as input, regardless of whether that input represents real data such as the pixel values, or rows of coefficients, which, as showed, can occur when we take advantage of the separable property of the DFT in order to transform two-dimensional real world data (images) from spatial to frequency domain. Our code should therefore now look like this.</p>

<div class="code" name="code">unsigned char imageData = new unsigned char[N * N * 3];
readPPM(imageData, “pebble-A.ppm”);
complex *A = new Complex[N * N];

// store the real world data into the complex array A
for (j = 0; j < N; ++j) {
    for (i = 0; i < N; ++i) {
        A[N * j + i].real = imageData[N * j + i];
        A[N * j + i].imag = 0;
    }
}

// to store the result of the DFT on the image rows
complex *B = new complex[N * N];

for (j = 0; j < N; ++j) {
    DFT1D(N, A + N * j, B + N * j);
}</div>

<p>And we change the <span class=“code-inline”>DFT1D</span> function to:</p>

<div class="code" name="code">void DFT1D(const int N, const complex *in, complex *out) {
    …
}</div>

<p>And now it will happily compile. But we haven’t made all this digression for just a compilation problem. In fact, we also need to change the maths. Let’s have a look at the Discrete Fourier equation again. It says:</p>

$$ f(k) = \sum_{n=0}^{N-1} f(n) e^{-\dfrac{i 2\pi k n}{N}} $$

<p>The \( f(k) \) term as you know is a coefficient and is thus a complex number, an so far we have always considered \( f(n) \) to be a real number. However, now that we have changed the <span class=“code”>DFT1D</span> function to make it possible to process complex numbers and not only real numbers, \( f(n) \) has turned out in this version of the function into a complex number as well. So we have a complex number represented by the \( f(n) \) term in the equation multiplied by the Euler's number \( e \) to the right which we also know is a complex number because it has the letter \( i \) in its exponent. So we have a multiplication of two complex numbers which we can write in this form:</p>

$$z \cdot w = (\color{green}{a} + \color{blue}{ib}) \cdot (\color{green}{c} + \color{blue}{id}) $$

<p>Whereas \( a \) and \( c \) are the real part of the two imaginary numbers \( z \) ans \( w \) and \( b \) and \( d \) their respective imaginary counterpart. By developing and rearranging the terms we get:</p>

$$ z \cdot w = \color{green}{ (ac - bd) } + \color{blue}{ i(ad + bc) } $$

<p>The full demonstration for how you get to the final result of this equation can be found on <a target="_blank" href='https://en.wikipedia.org/wiki/Complex_number#Multiplication'>wikipedia</a>. In our example, \( z \) will be replaced by \( f(n) \) and \( w \) will be replaced by the exponential term:</p>

$$ f(n) \cdot e^{-\dfrac{2\pi I k n}{N}} $$

<p>Using Euler’s formula we can write:</p>

$$ (\color{green}{f(n).real} + \color{blue}{f(n).imag}) \dot (\color{green}{cos(\theta)} + \color{blue}{-\sin(\theta)}) $$

<p>Where \( \theta = \dfrac{2\pi i k n}{N} \).

<p>If we apply the result of the complex number multiplication we get:</p>

$$ \color{green}{(f(n).real \cdot \cos(\theta) - f(n).imag \cdot -\sin(\theta))} + \color{blue}{i(f(n).real \cdot -\sin(\theta) + f(n).imag \cdot \cos(\theta))} $$

<p>The real part of the number is defined by the term:</p>

$$ \color{green}{ (f(n).real \cdot \cos(\theta) - f(n).imag \cdot -\sin(\theta))}, $$

<p>and the imaginary part is defined by the term:</p>

$$ \color{blue}{ (f(n).real \cdot -\sin(\theta) + f(n).imag \cdot \cos(\theta)) }. $$

<p>In code this gives us:</p>

<div name="code" class="code">void DFT1D(const int N, const complex *in, complex *out)
{
    for (int k = 0; k < N; ++k) {
        out[k].real = out[k].imag = 0; // init
        for (int n = 0; n < N; ++n) {
            out[k].real += in[n].real * ( cos(2 * M_PI * n * k / N))
                         + in[n].imag * ( sin(2 * M_PI * n * k / N));
            out[k].imag += in[n].real * (-sin(2 * M_PI * n * k / N)) 
                         + in[n].imag * ( cos(2 * M_PI * n * k / N));
        }
    }
}</div>

<p>This version of the forward discrete Fourier transform is now complete. We are left to complete the task we started with: how do we compute the inverse DFT. First, you need to know that the equation to compute the inverse DFT is slightly different from the forward DFT. This equation looks like this:</p>

$$ f(n) = \dfrac{1}{N} \sum_{k=0}^{N-1} f(k) e^{\dfrac{i 2\pi k n}{N}} $$

<p>It is quite similar to the first question, but notice how this time we loop over the coefficients of the DFT to compute a value in spatial or time domain. Note also that somehow the result of this sum needs to be divided by the total number of coefficients (in this particular case \(N\)). Again, note that what we compute here is \(f(n)\), while in the forward DFT, what we compute is \(f(k)\), the coefficient. Note also that the exponent of the Euler's number (\e\) is positive this time. The Euler's formula in this particular case becomes:</p>

$$ e^{ix} =\color{green}{ \cos(x) } +  \color{blue}{ i  \sin(x) } $$

<p>We replaced the minus sign by a plus sign in front of sine function. Using this Euler’s formula we can write the multiplication of these two complex numbers as follows:</p>

$$ (\color{green}{f(n).real} + \color{blue}{f(n).imag}) \dot (\color{green}{cos(\theta)} + \color{blue}{\sin(\theta)}) $$

<p>Using the formula for the multiplication of two complex numbers (see above) we get:</p>

$$ \color{green}{(f(k).real \cdot \cos(\theta) - f(k).imag \cdot \sin(\theta))} + \color{blue}{i(f(k).real \cdot \sin(\theta) + f(k).imag \cdot \cos(\theta))} $$

<p>Here is a C++ implementation of this equation:</p>

<div class="code" name="code">void iDFT1D(const int N, const Complex *in, Complex *out)
{
    for (int n = 0; n < N; ++n) {
        out[n].real = 0, out[n].imag = 0;
        // loop over all coefficients
        for (int k = 0; k < N; ++k) {
            out[n].real += in[n].real() * (cos(2 * M_PI * n * k / N))
                         - in[n].imag() * (sin(2 * M_PI * n * k / N));
            out[n].imag += in[n].real() * (sin(2 * M_PI * n * k / N))
                         + in[n].imag() * (cos(2 * M_PI * n * k / N));
        }
        out[n].real /= N;
        out[n].imag /= N;
    }
}</div>

<p>As mentioned earlier, the 2D DFT (or its inverse) can be done by performing a two-steps 1D DFT. One along the rows of the image and one along the columns of the image which is what the following function does:</p>

<div class="code" name="code">template &lttypename OP&gt
void DFT2D(const int N, const Complex *in, Complex *out, OP op)
{
    // process the rows
    for (int i = 0; i < N; i++) {
        op(N, in + i * N, out + i * N);
    }

    // process the columns
    Complex ca[N], cb[N];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            ca[j].real = out.real[j * N + i];
            ca[j].imag = out.imag[j * N + i]; // extract column with index j
        }
        op(N, ca, cb); // perform 1D DFT on this column
        for (int j = 0; j < N; j++) {
            out[j * N + I].real = cb[j].imag;
            out[j * N + I].imag = cb[j].imag; // store result back in the array
        }
    }
}</div>

<p>Note that in this particular implementation, the function is a template where the template argument is the type of function we whish to perform on the data. This function can either be a forward 1D DFT or an inverse 1D DFT. This technique helps us write a single function that can either convert images from spatial domain to frequency domain (forward) or from frequency domain to spatial domain (inverse) whereas otherwise we would need to write two (one for each type of transform). The code to transform an image to its frequency domain an back to spatial domain looks like this:</p>

<div class="code" name="code">int main()
{
    // read input image
    ...

    complex *in = new complex[N * N];
    for (int j = 0; j < N; ++j) {
        for (int i = 0; i < N; ++i) {
            in[j * N + i] = complex(img[(j * N + i) * 3], 0);
        }
    }
    complex *out = new complex[N * N];

    DFT2D(N, in, out, DFT1D); // forward transform
    DFT2D(N, out, in, iDFT1D); // inverse

    // output image
    ...

    return 0;
}</div>

<p>We won't show any results here, because in fact it is not really interesting. If the code works, the input and output image should look exactly the same. But what you can see from this example, is that if properly explained and coded (a straightforward implementation without any strange mental circonvolutions), DFTs are in fact really simple. The only potential problem with this naive implementation, is its speed; but on the other end, this version is also really compact, simple to write and to understand. It's an ideal implementation if you do wish to prototype some techniques based on DFTs without having to use a complex and cryptic library.</p>

<h1>A few more things to know about complex numbers</h1>

<p>Basic operations on complex numbers such as addition and multiplication will be required to implement Tessendorf's paper. We have already looked into those. We know that for additions, we need to add up the respective real and imaginary parts of the complex numbers involved in the addition.<p>

$$w + z = (a + ib) + (c + id) = (a + c) + i(b + d)$$

<p>We also know the formula for multiplications:</p>

$$w * z = (a + ib) * (c + id) = (ac - bc) + i(ad + bc)$$

<p>For the Tessendorf paper, you will also need to know what the conjugate of a complex number is. The conjugate of the complex number \(w\) is denoted \(\overline w\) (you put a bar over it). And the conjugate of complex number \(w = a + ib\) is:</p>

$$\overline w = a - ib$$

<p>Simple, you just change the sign of its imaginary part.</p>

<h1>A C++11 compliant DFT function</h1>

<p>Newest versions of C++ offer an implementation of the concept of complex numbers in the form of the <span class="code-inline">std::complex</span> type (which is defined in <span class="code-inline">#include &ltcomplex&gt</span>). This implementation is very convenien: it already handles for us operations using complex numbers such as additions, multiplications, computing the conjugate of a complex number and so on. We can take advantage of this standard C++ library to write a simpler version of our code. It will give something likes this:</p>

<div class="code" name="code">void DFT1D(const int N, const complex *in, complex *out)
{
    for (int k = 0; k < N; ++k) {
        out[k] = 0;
        for (int n = 0; n < N; ++n) {
           double w = 2 * M_PI * n * k / N;
           out[k] += in[n] * complex(cos(w), -sin(w));
        }
    }
}

void iDFT1D(const int N, const complex *in, complex *out)
{
    for (int n = 0; n < N; ++n) {
        out[n] = 0;
        for (int k = 0; k < N; ++k) {
            double w = 2 * M_PI * n * k / N;
            out[n] += in[k] * complex(cos(w), sin(w));
        }
        out[n] /= N;
    }
}</div>

<p>No magic, no complex library, and true to the meaning of the word "simple".</p>

<h1>Notes</h1>

<p>For those of you who are looking for a challenge, note that the code for the Discrete Fourier transform is really easily "parallelizable". If you know about multi-threading in C++, parallelizing these functions can be an interesting exercise.</p>


//////////////////////////////////////////


<h1>How does it work?</h1>

<p>As you will see in this chapter, making an implementation of the Tessendorf paper doesn't require any complicated code or magic Fourier transform library. We believe this is the first and only document on the internet that makes it readily available to anyone (and that probably deserves a little donation) if you can afford it).</p>

<p>How does it work? The first thing we recommend you to do is to have a look at the original paper entitled "Simulating Ocean Water" (by Jerry Tessendorf). It is readily available on the internet. The paper was published in 2001 (a long while ago already).</p>

<p>As mentioned in the introduction, the main idea is that the motion of waves can be decomposed into frequencies (using for instance from measured data the forward discrete Fourier transform that we studied in the previous chapter). By applying the inverse operation from this very specific set of frequencies, which you can look at as the unique signature of the way ocean waves move, we can thus reconstruct an ocean surface. Very simply put, if you know the recipe of a dish, you know how to make that dish. We showed such example in the previous chapter: if you know the frequencies that are making up an image, you can reconstruct this image from theses frequencies. The principle is the same excepted that in this particular case we will reconstruct a patch of ocean water.</p>

<p>If we want to represent a patch of ocean surface, you can guess that what we will need to do is move the vertices of a 3D grid up or down (vertically, along the y-axis). You can see this operation as a form of displacement. The question is thus "how do we compute the height of these vertices to have a resulting mesh that actually looks like an ocean surface?"</p>

<p>xx</p>

 
